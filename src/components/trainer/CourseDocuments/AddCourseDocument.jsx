import React, { useState } from 'react';
import {
  Box,
  Typography,
  Paper,
  TextField,
  Button,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Grid,
  Alert,
  LinearProgress,
  Chip,
  IconButton,
  Snackbar,
  CircularProgress
} from '@mui/material';
import {
  CloudUpload,
  ArrowBack,
  Add,
  Delete,
  CheckCircle,
  ErrorOutline
} from '@mui/icons-material';
import { useNavigate } from 'react-router-dom';
import { courseDocumentsAPI } from '../../../services/API/courseDocuments';

const AddCourseDocument = () => {
  const [formData, setFormData] = useState({
    title: '',
    batchId: ''
  });
  const [files, setFiles] = useState([]);
  const [uploadProgress, setUploadProgress] = useState(0);
  const [uploading, setUploading] = useState(false);
  const [error, setError] = useState('');
  const [snackbar, setSnackbar] = useState({ open: false, message: '', severity: 'success' });
  
  const navigate = useNavigate();

  const handleInputChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
  };

  const handleFileChange = (e) => {
    const selectedFiles = Array.from(e.target.files);
    
    // Validate file types
    const allowedTypes = [
      'application/pdf',
      'application/msword',
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
      'application/vnd.ms-powerpoint',
      'application/vnd.openxmlformats-officedocument.presentationml.presentation',
      'text/plain',
      'application/vnd.ms-excel',
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      'video/mp4',
      'video/avi',
      'video/quicktime',
      'audio/mp3',
      'audio/wav',
      'image/jpeg',
      'image/jpg',
      'image/png',
      'image/gif'
    ];

    const validFiles = selectedFiles.filter(file => {
      if (!allowedTypes.includes(file.type)) {
        setError(`File type ${file.type} is not supported for ${file.name}`);
        return false;
      }
      if (file.size > 50 * 1024 * 1024) { // 50MB limit
        setError(`File ${file.name} is too large. Maximum size is 50MB`);
        return false;
      }
      return true;
    });

    if (validFiles.length > 0) {
      setFiles(prev => [...prev, ...validFiles]);
      setError(''); // Clear any previous errors
    }
  };

  const removeFile = (index) => {
    setFiles(prev => prev.filter((_, i) => i !== index));
  };

  // Validate form data - only required fields
  const validateForm = () => {
    const errors = [];

    if (!formData.title.trim()) {
      errors.push('Document title is required');
    }
    if (!formData.batchId.trim()) {
      errors.push('Batch ID is required');
    }
    if (files.length === 0) {
      errors.push('Please select at least one file to upload');
    }

    return errors;
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    // Validate form
    const validationErrors = validateForm();
    if (validationErrors.length > 0) {
      setError(validationErrors.join(', '));
      return;
    }

    setUploading(true);
    setError('');
    setUploadProgress(0);

    // Declare progressInterval outside try block so it's accessible in catch/finally
    let progressInterval;

    try {
      // Simulate upload progress
      progressInterval = setInterval(() => {
        setUploadProgress(prev => {
          if (prev >= 90) {
            clearInterval(progressInterval);
            return 90; // Stop at 90% until API call completes
          }
          return prev + 10;
        });
      }, 200);

      // Process each file (if multiple files, we'll upload them one by one)
      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        
        // Validate file exists and is valid
        if (!file || file.size === 0) {
          throw new Error('Invalid file selected');
        }
        
        // Create the document data object with ONLY required fields
        const documentData = {
          // Only the fields that are manually entered or required
          Batch_ID: parseInt(formData.batchId),        // User enters manually
          Document_Title: formData.title.trim(),       // User enters manually
          file: file                                   // Actual file for upload (will be sent as Document_Path)
          // Note: Document_ID and Document_Upload_DateTime are auto-generated by API
        };
        
        // Debug logging to verify data being sent
        console.log('=== Document Data Debug Info ===');
        console.log('File details:', {
          name: file.name,
          size: file.size,
          type: file.type,
          lastModified: file.lastModified
        });
        
        console.log('Document data being sent:', {
          Batch_ID: documentData.Batch_ID,
          Document_Title: documentData.Document_Title,
          fileName: file.name,
          fileSize: file.size
        });
        
        console.log('=== Sending API Request ===');
        
        // Make API call with the document data object (not FormData)
        const response = await courseDocumentsAPI.add(documentData);
        console.log('Upload response:', response);
        
        // Verify response structure matches expected API response
        if (response && response.Document_ID) {
          console.log('Successfully uploaded document with ID:', response.Document_ID);
        }
      }

      // Complete progress
      if (progressInterval) {
        clearInterval(progressInterval);
      }
      setUploadProgress(100);

      // Show success message
      setSnackbar({
        open: true,
        message: `Successfully uploaded ${files.length} document(s)!`,
        severity: 'success'
      });

      // Reset form
      setFormData({ title: '', batchId: '' });
      setFiles([]);

      // Redirect after a short delay
      setTimeout(() => {
        navigate('/trainer/course-documents');
      }, 2000);

    } catch (err) {
      console.error('Upload error:', err);
      
      // Clear progress interval if still running
      if (progressInterval) {
        clearInterval(progressInterval);
      }
      
      const errorMessage = err.message || 'Failed to upload document. Please try again.';
      setError(`Failed to add course document: ${errorMessage}`);
      setSnackbar({
        open: true,
        message: errorMessage,
        severity: 'error'
      });
    } finally {
      setUploading(false);
      // Clear progress interval if still running (safety check)
      if (progressInterval) {
        clearInterval(progressInterval);
      }
      // Reset progress after a delay
      setTimeout(() => setUploadProgress(0), 3000);
    }
  };

  // Helper function to determine file type
  const getFileType = (file) => {
    const extension = file.name.split('.').pop()?.toLowerCase();
    switch (extension) {
      case 'pdf': return 'PDF';
      case 'doc':
      case 'docx': return 'DOC';
      case 'ppt':
      case 'pptx': return 'PPT';
      case 'xls':
      case 'xlsx': return 'XLS';
      case 'mp4':
      case 'avi':
      case 'mov': return 'VIDEO';
      case 'mp3':
      case 'wav': return 'AUDIO';
      case 'jpg':
      case 'jpeg':
      case 'png':
      case 'gif': return 'IMAGE';
      case 'txt': return 'TXT';
      default: return extension?.toUpperCase() || 'UNKNOWN';
    }
  };

  const formatFileSize = (bytes) => {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  };

  const handleCloseSnackbar = () => {
    setSnackbar({ ...snackbar, open: false });
  };

  return (
    <Box sx={{ p: 3 }}>
      <Box sx={{ display: 'flex', alignItems: 'center', mb: 3 }}>
        <IconButton onClick={() => navigate('/trainer/course-documents')} sx={{ mr: 1 }}>
          <ArrowBack />
        </IconButton>
        <Typography variant="h4" component="h1">
          Add Course Document
        </Typography>
      </Box>

      {error && (
        <Alert severity="error" sx={{ mb: 3 }} onClose={() => setError('')}>
          {error}
        </Alert>
      )}

      <Paper sx={{ p: 3 }}>
        <form onSubmit={handleSubmit}>
          <Grid container spacing={3}>
            <Grid item xs={12} md={6}>
              <TextField
                fullWidth
                label="Document Title"
                name="title"
                value={formData.title}
                onChange={handleInputChange}
                required
                disabled={uploading}
                placeholder="Enter document title"
              />
            </Grid>

            <Grid item xs={12} md={6}>
              <TextField
                fullWidth
                label="Batch ID"
                name="batchId"
                value={formData.batchId}
                onChange={handleInputChange}
                required
                disabled={uploading}
                placeholder="Enter batch ID (e.g., 1, 2, 3)"
                type="number"
                inputProps={{ min: 1 }}
              />
            </Grid>

            {/* File Upload Section */}
            <Grid item xs={12}>
              <Typography variant="h6" gutterBottom>
                Upload Files (Required)
              </Typography>
              <Box sx={{ border: '2px dashed #ccc', borderRadius: 2, p: 3, textAlign: 'center' }}>
                <input
                  type="file"
                  multiple
                  onChange={handleFileChange}
                  style={{ display: 'none' }}
                  id="file-upload"
                  accept=".pdf,.doc,.docx,.ppt,.pptx,.txt,.xls,.xlsx,.mp4,.avi,.mov,.mp3,.wav,.jpg,.jpeg,.png,.gif"
                />
                <label htmlFor="file-upload">
                  <Button
                    variant="outlined"
                    component="span"
                    startIcon={<CloudUpload />}
                    size="large"
                    disabled={uploading}
                    sx={{
                      borderColor: uploading ? '#ccc' : 'primary.main',
                      '&:hover': {
                        borderColor: uploading ? '#ccc' : 'primary.dark'
                      }
                    }}
                  >
                    {uploading ? 'Uploading...' : 'Choose Files'}
                  </Button>
                </label>
                <Typography variant="body2" color="textSecondary" sx={{ mt: 1 }}>
                  Supported formats: PDF, DOC, DOCX, PPT, PPTX, TXT, XLS, XLSX, MP4, AVI, MOV, MP3, WAV, JPG, PNG, GIF
                </Typography>
                <Typography variant="body2" color="textSecondary">
                  Maximum file size: 50MB per file
                </Typography>
              </Box>

              {/* Selected Files */}
              {files.length > 0 && (
                <Box sx={{ mt: 2 }}>
                  <Typography variant="subtitle1" gutterBottom>
                    Selected Files ({files.length})
                  </Typography>
                  {files.map((file, index) => (
                    <Chip
                      key={index}
                      label={
                        <Box>
                          <Typography variant="body2" component="span">
                            {file.name}
                          </Typography>
                          <Typography variant="caption" component="div">
                            {formatFileSize(file.size)} â€¢ {getFileType(file)}
                          </Typography>
                        </Box>
                      }
                      onDelete={() => removeFile(index)}
                      deleteIcon={<Delete />}
                      disabled={uploading}
                      sx={{ mr: 1, mb: 1, height: 'auto', '& .MuiChip-label': { display: 'block', py: 1 } }}
                    />
                  ))}
                </Box>
              )}
            </Grid>

            {/* Upload Progress */}
            {uploading && (
              <Grid item xs={12}>
                <Box sx={{ mt: 2 }}>
                  <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
                    <Typography variant="body2">
                      Uploading documents...
                    </Typography>
                    <Typography variant="body2">
                      {uploadProgress}%
                    </Typography>
                  </Box>
                  <LinearProgress variant="determinate" value={uploadProgress} />
                </Box>
              </Grid>
            )}

            {/* Action Buttons */}
            <Grid item xs={12}>
              <Box sx={{ display: 'flex', gap: 2, justifyContent: 'flex-end' }}>
                <Button
                  variant="outlined"
                  onClick={() => navigate('/trainer/course-documents')}
                  disabled={uploading}
                >
                  Cancel
                </Button>
                <Button
                  type="submit"
                  variant="contained"
                  disabled={uploading || files.length === 0}
                  startIcon={uploading ? <CircularProgress size={20} color="inherit" /> : <Add />}
                >
                  {uploading ? `Uploading... (${uploadProgress}%)` : `Upload ${files.length > 0 ? files.length : ''} Document${files.length !== 1 ? 's' : ''}`}
                </Button>
              </Box>
            </Grid>
          </Grid>
        </form>
      </Paper>

      {/* Success/Error Snackbar */}
      <Snackbar
        open={snackbar.open}
        autoHideDuration={6000}
        onClose={handleCloseSnackbar}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
      >
        <Alert
          onClose={handleCloseSnackbar}
          severity={snackbar.severity}
          icon={snackbar.severity === 'success' ? <CheckCircle /> : <ErrorOutline />}
        >
          {snackbar.message}
        </Alert>
      </Snackbar>
    </Box>
  );
};

export default AddCourseDocument;